
# Синхронизация zoom-навигации с фильтрами (фильтры как breadcrumbs)

## Идея

Вместо отдельного компонента breadcrumbs использовать существующие фильтры Units/Teams как индикатор текущей позиции в иерархии. Когда пользователь зумится в юнит на тримапе, этот юнит автоматически выбирается в фильтре. Фильтры становятся и навигацией, и контекстом одновременно.

## Архитектурная проблема и решение

Сейчас zoom (focusedPath) и фильтры — две независимые системы:
- **focusedPath**: визуальный зум, все данные остаются в дереве, координаты масштабируются
- **Фильтры**: реально удаляют данные из дерева

Если обновить фильтр одновременно с зумом, дерево пересоберется и соседние узлы исчезнут из данных до завершения анимации -- анимация сломается.

**Решение**: отложенная синхронизация. focusedPath управляет анимацией как раньше. После завершения анимации (~после duration) фильтры обновляются, чтобы отразить текущую позицию. Поскольку к этому моменту зум уже завершен и показан только целевой узел, пересборка дерева визуально незаметна.

## Поведение

```text
Zoom in (клик на юнит "Tech Platform"):
  1. focusedPath = ['Tech Platform'] -- анимация зума (400-1200мс)
  2. После анимации: selectedUnits = ['Tech Platform'], selectedTeams = [все команды юнита]
  3. Фильтр "Юниты" отображает "Tech Platform" -- пользователь видит где он

Zoom in глубже (клик на команду "Backend"):
  1. focusedPath = ['Tech Platform', 'Backend'] -- анимация
  2. После анимации: selectedTeams = ['Backend']
  3. Фильтр "Команды" отображает "Backend"

Zoom out (кнопка назад):
  1. focusedPath = ['Tech Platform'] -- анимация возврата
  2. После анимации: selectedTeams = [все команды юнита], selectedUnits = ['Tech Platform']

Zoom out на верхний уровень:
  1. focusedPath = [] -- анимация возврата
  2. После анимации: selectedUnits = [], selectedTeams = []
  3. Фильтры показывают "Юниты", "Команды" -- всё сброшено

Ручное изменение фильтра пользователем:
  focusedPath сбрасывается в [], тримап показывает отфильтрованный набор данных без зума
```

## Технические изменения

### 1. `src/components/treemap/TreemapContainer.tsx`

- Новый проп: `onZoomChange?: (path: string[]) => void` -- вызывается после завершения анимации зума
- В handleNodeClick: после `setTimeout` (который уже есть для блокировки кликов, ~900мс) вызывать `onZoomChange(newFocusedPath)`
- В handleNavigateBack: аналогично вызывать `onZoomChange` с укороченным путём
- При получении нового пропа `externalFocusedPath` (от ручного изменения фильтров) -- сбросить внутренний focusedPath

### 2. `src/pages/Index.tsx`

- Новый обработчик `handleZoomChange(path: string[])`:
  - Если path пуст: очистить selectedUnits и selectedTeams
  - Если path[0] -- юнит: выбрать его в selectedUnits, авто-выбрать все его команды
  - Если path[1] -- команда: выбрать её в selectedTeams
- Передать handleZoomChange в BudgetTreemap и StakeholdersTreemap
- При ручном изменении фильтров (toggleUnit/toggleTeam в FilterBar): сбросить focusedPath через новый проп

### 3. `src/components/BudgetTreemap.tsx` и `src/components/StakeholdersTreemap.tsx`

- Прокинуть новый проп `onZoomChange` в TreemapContainer

### 4. Обратная синхронизация (фильтры -> zoom)

- Новый проп в TreemapContainer: `resetZoom?: boolean` (или триггер)
- Когда пользователь вручную меняет фильтр в FilterBar, Index.tsx устанавливает флаг, который сбрасывает focusedPath в TreemapContainer
- Это предотвращает конфликт между ручными фильтрами и zoom-состоянием

## Что НЕ меняется

- Анимации zoom-in/out остаются как есть
- focusedPath по-прежнему управляет визуальным зумом
- Фильтры по-прежнему фильтруют данные
- Кнопка "Наверх" работает как раньше через focusedPath

## Результат

- Фильтры наверху показывают текущую позицию в иерархии (работают как breadcrumbs)
- Нет нового UI-элемента, интерфейс не перегружен
- Пользователь может и кликать по тримапу, и менять фильтры вручную -- оба пути синхронизированы
