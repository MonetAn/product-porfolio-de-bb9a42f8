
## Цели (что сделаем)
1) Вернуть нормальную скорость анимаций (убрать slow-motion debug: 3s).
2) Разобраться, почему после множества итераций анимируется в основном только “главный” квадрат, а соседи выглядят как fade-out.
3) Сделать так, чтобы соседи реально “улетали” за рамки при zoom-in (drilldown) — если это технически возможно в текущей архитектуре, и понять ограничения, если нет.
4) Сохранить твой Isolation Test (отключение layoutId/layout projection) как диагностический шаг, но довести его до корректного эксперимента.

---

## Ключевое наблюдение по текущему коду (почему сейчас “главный” квадрат анимируется, а соседи не улетают)
### Проблема №1 (самая критичная): мы ломаем идентификацию zoom-target’а на exit-слое
В `TreemapContainer.tsx` в цикле `nodesForExit.map(...)` сейчас делается:
- React `key` у компонента: `key={`exit-${node.key}`}`
- И ОДНОВРЕМЕННО меняется `node.key` внутри передаваемого объекта: `key: \`exit-\${node.key}\``

А в `TreemapNode.tsx` zoom-target определяется так:
- `const isZoomTarget = zoomTarget?.key === node.key;`

Но `zoomTargetInfo.key` устанавливается из “старого” ключа клика (`clickedNode.key` без `exit-`), а у exit-ноды `node.key` уже с префиксом `exit-`.

Итог:
- На exit-слое “целевой” блок НЕ считается target → он не расширяется на весь экран в `animate/exit`.
- А новый слой (`layoutNodes`) позже появляется и именно там target совпадает по ключу → поэтому кажется, что “анимация есть только у основного квадрата”.

Это объясняет очень многое: почему соседи “просто исчезают” (визуально подмена слоёв) и почему “рамки не двигают друг друга”.

### Проблема №2: exit-анимация может вообще не запускаться так, как мы ожидаем
AnimatePresence запускает `exit` только когда компонент УДАЛЯЕТСЯ из React дерева.

Сейчас exit-слой (`nodesForExit`) рендерится пока `nodesForExit.length > 0`, и очищается через `onExitComplete`, который в свою очередь сработает только когда кто-то реально выходит. Из-за этого можно получить “логическую ловушку”, где:
- exit-слой долго висит,
- новый слой включается таймером,
- визуально это похоже на “появление/исчезновение” вместо физического вытеснения.

---

## Почему было много итераций, а результат не достигнут (рефлексия по причине)
1) Мы лечили симптомы (stale closure/customData, условный рендер по animationType, hover re-render), но оставалась фундаментальная ошибка идентификации target на exit-слое (из-за переписывания `node.key`).
2) Слишком много “магии” одновременно:
   - Layout Projection (layoutId),
   - ручные variants x/y/width/height,
   - 2 слоя (exit слой + новый слой),
   - асинхронный showNewNodes.
   В таких системах один неправильный идентификатор или порядок unmount/mount полностью ломает картинку, а визуально выглядит как “fade”.
3) Мы использовали `node.key` как:
   - React key,
   - layoutId,
   - бизнес-идентификатор для определения zoomTarget.
   Это опасное смешение. Нужно разделить: “React key для списка” ≠ “стабильный id ноды” ≠ “layoutId”.

---

## Реально ли сделать “соседи улетают за рамки”?
Да, это возможно при текущем подходе (Framer Motion + абсолютные позиции + variants), но нужно соблюсти 3 условия:

1) **Exit-слой должен знать, кто target** (стабильный id совпадает).
2) **Exit-ноды должны реально получать `exit`** (должен происходить unmount exit-слоя в нужный момент).
3) **Layout projection не должен перетирать manual exit**:
   - либо мы отключаем layoutId/layout на exit-ноду (твой вариант),
   - либо строим архитектуру “layoutId только для обычных переходов”, а для exit — отдельный слой без layoutId.

Если после исправления идентификаторов и корректного момента unmount соседи всё равно “не летят”, тогда действительно виноват layout projection (и твой isolation test это подтвердит). Но сейчас тест “грязный”, потому что target на exit-слое вообще не target из-за `exit-` префикса.

---

## Что именно поменяем (план работ)

### Часть A — Вернуть нормальную скорость анимаций
1) `src/components/treemap/types.ts`
   - Вернуть `ANIMATION_DURATIONS.drilldown` и `ANIMATION_DURATIONS['navigate-up']` к нормальным значениям (из комментариев видно, что было 500/600).
   - Примерно:
     - drilldown: 600ms (или 500–600, как было)
     - navigate-up: 600ms
2) `src/components/treemap/TreemapNode.tsx`
   - Вернуть `ZOOM_TRANSITION.duration` с `3.0` на `0.6` (как в комментарии “was 0.6”).

Это убирает “замедленную” сцену и делает тестирование ближе к реальности.

---

### Часть B — Починить главную логическую ошибку: не переписывать `node.key` в exit-слое
1) `src/components/treemap/TreemapContainer.tsx`
   - В `nodesForExit.map(...)` оставить `node` как есть (НЕ менять `node.key`).
   - Менять только React `key` у компонента (это безопасно), например `key={`exit-${node.key}`}` — этого достаточно, чтобы React отличал exit-слой от нового слоя.
   - Важно: `zoomTargetInfo.key` должен сравниваться с исходным `node.key`, иначе target не находится.

Ожидаемый эффект:
- exit-слой наконец-то будет понимать, кто zoom target.
- значит, `animate`/`exit` ветки для target реально начнут работать на exit-слое.

---

### Часть C — Сделать “правильный unmount” exit-слоя, чтобы `exit` реально отрабатывал как “улёт”
Сейчас `showNewNodes` включается таймером, но exit-слой не обязательно “уходит” в правильный момент.

Мы сделаем явное правило:
- во время drilldown, сначала показываем exit-слой
- затем в нужный момент начинаем показывать новый слой
- затем убираем exit-слой (тем самым вызываем его `exit`)

Практически:
1) В `TreemapContainer.tsx`:
   - Привязать рендер `nodesForExit` к `animationType === 'drilldown' && !showNewNodes` или к отдельному флагу “exitingPhase”.
   - Когда `showNewNodes` становится true — в этот же рендер мы перестаём рендерить exit-слой → это и запускает `exit` на старых компонентах.

Важно:
- `onExitComplete` тогда станет реально полезным: он сработает после вылета старых нод и очистит `nodesForExit/zoomTargetInfo`.

---

### Часть D — Твой Isolation Test (сделать его корректным и максимально “чистым”)
Цель: проверить твою гипотезу, что layout projection (layoutId/layout) перетирает manual exit x/y.

1) `src/components/treemap/TreemapNode.tsx`
   - Сейчас мы уже делаем: `layoutId={shouldDisableLayout ? undefined : node.key}`.
   - Но ты хочешь “полностью тупой motion.div” для exit-ноды. Значит:
     - если `isExitingNode && !isZoomTarget`, то убрать не только `layoutId`, но и любые `layout`-пропы (сейчас layout не используется, но мы проверим, что нигде не прокидывается).
   - Оставить красную рамку `border: 5px solid red` только для exit non-target (как сейчас).

2) `src/components/treemap/TreemapContainer.tsx`
   - Для exit-нод продолжать прокидывать `isExitingNode={true}`.
   - После фикса `node.key` (Часть B) target на exit-слое станет target, а значит:
     - target будет без красной рамки,
     - соседи будут с красной рамкой и должны “улетать” по `getEdgeBasedExitAnimation()`.

Критерий успеха теста:
- красные блоки реально уходят за видимую область, без opacity=0.
- в логах `EXIT variant triggered` для соседей должно быть `hasCustomData: true` и `customAnimationType: 'drilldown'`.

Если после этого красные блоки всё равно “не летят”, тогда гипотеза про layout projection подтверждается на 100%, и мы фиксируем это архитектурно: “exit слой без layoutId/layout всегда”.

---

## Почему может оставаться fade-out даже после отключения layoutId (если вдруг)
Если после всех исправлений всё ещё будет fade:
1) Значит реально срабатывает fallback ветка `exit`:
   - `customData` приходит null
   - или `exitAnimationType !== 'drilldown'`
   Тогда соседи пойдут в `opacity: 0`.
   Решение: в момент drilldown гарантировать `zoomTargetInfo` не null на весь жизненный цикл exit-слоя (не чистить раньше времени) и убедиться, что `custom` прокинут на AnimatePresence И на TreemapNode.

2) Если exit-ноды вообще не получают `exit` (не размонтируются), то они никогда не “полетят” — будут просто висеть/перекрываться.
   Решение: часть C (правильный unmount) обязательна.

---

## Технический чек-лист после правок (как мы проверим)
1) Вернули duration к 0.6s/600ms.
2) Кликаем на Unit:
   - видим красные рамки у соседей (значит это exit-слой non-target).
   - target расширяется.
   - красные блоки улетают за экран (а не исчезают через прозрачность).
3) Смотрим консоль:
   - `EXIT variant triggered` для красных блоков: `hasCustomData: true`, `customAnimationType: 'drilldown'`.
4) Проверяем navigate-up: узлы прилетают с краёв как раньше.
5) Если всё ок — удаляем/смягчаем debug-рамку и debug opacity 0.5 у target (вернём opacity 1).

---

## Результат, который считаю достижимым
- Да, “соседи улетают за рамки” достижимо.
- Прямо сейчас основная причина, почему оно не происходит стабильно: сломан идентификатор target на exit-слое (мы сами переписали `node.key`), плюс неоднозначный жизненный цикл exit-слоя.
- После разделения “React key” и “node.key как id”, и корректного unmount exit-слоя, твой isolation test станет валидным и с высокой вероятностью покажет нужное поведение.

---

## Какие файлы будут изменены
1) `src/components/treemap/types.ts` — вернуть нормальные `ANIMATION_DURATIONS` (убрать 3000ms debug).
2) `src/components/treemap/TreemapNode.tsx` — вернуть `ZOOM_TRANSITION.duration` к 0.6s; сохранить/уточнить отключение layoutId + красную рамку в режиме теста.
3) `src/components/treemap/TreemapContainer.tsx` — исправить exit-слой:
   - не переписывать `node.key`,
   - правильно размонтировать exit-слой в нужный момент (чтобы `exit` реально запускался).

