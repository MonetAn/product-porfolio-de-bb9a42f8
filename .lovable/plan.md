
### Текущее состояние и что я вижу по фактам

**Симптом:** “двигается только основной квадрат (target), соседи не «вытесняются»”.

**По коду сейчас реально происходят две разные потенциальные ситуации:**
1) **Ветка drilldown-«push» вообще не запускается** (тогда соседи просто исчезают/перерисовываются обычным join’ом).  
2) **Ветка запускается, но соседи «едут», однако визуально их не видно**, потому что expanding-target перекрывает их из‑за особенностей SVG layering (порядок отрисовки), и/или потому что новые «enter» ноды рисуются поверх exit-слоя.

С учётом вашего описания (“видно только, что расширяется target”), наиболее вероятно **(2)**: анимации соседей технически идут, но они **находятся “под” expanding-target или под новыми нодами**.

---

## 1) Почему у Flourish treemap «вытесняет», а у нас нет (ключевая разница)

### Flourish (типичная D3-модель)
- Flourish держит **стабильный DOM**: те же `<rect>`/`<g>` остаются в SVG, меняются координаты/масштаб.
- При drilldown он обычно делает **zoom (camera)**:
  - либо трансформирует общий контейнер (`<g transform="translate... scale...">`)
  - либо использует clip/viewport подход
- Соседи “вытесняются” потому что:
  - они **не пересоздаются**,
  - их позиции есть “до” и “после” в том же DOM,
  - z-order контролируется внутри SVG-групп, часто есть отдельные слои.

### Наша текущая архитектура
- При клике мы меняем данные (`data`, фильтры) → React пересобирает дерево → D3 layer получает уже новый набор нод.
- Чтобы симулировать «старый мир», мы сделали workaround: **exitingNodes** рисуются как временные группы (`g.exiting-node`) и анимируются отдельно.
- Это работоспособно, но очень чувствительно к:
  - **порядку отрисовки (SVG stacking order)**,
  - моменту появления новых нод (enter),
  - корректной идентификации target и соседей.

Итог: у Flourish эффект “нативный”, у нас — “симуляция старого мира”, поэтому нужно дополнительно управлять слоями и таймингами.

---

## 2) Какие решения из наших итераций не сработали (и почему)

### Решение A: “Снимок exitingNodesRef + pendingZoomTargetRef”
- Это решило проблему race-condition **частично** (target хотя бы расширяется).
- Но эффект “вытеснения” может не проявиться, если:
  - exitingNodes либо не те,
  - либо они есть, но **невидимы из‑за перекрытия**.

### Решение B: “flattenAllNodes в TreemapContainer”
- Это правильная линия — нужно иметь доступ к узлам разных уровней.
- Но даже при корректном списке, эффект может не проявиться из‑за D3Layer (см. ниже).

### Решение C (важное): текущая реализация в `TreemapD3Layer.tsx`
Ветка drilldown сейчас делает:
- рисует exitGroups (включая target и соседей)
- target **расширяется до full-screen**
- соседи улетают (transform)
- потом добавляются enter-ноды (новое состояние) и они могут оказаться **поверх** exitGroups

Главная проблема:
- В SVG **нет нормального CSS z-index** для отдельных `g` в привычном смысле.
- Отображение “кто сверху” определяется **порядком DOM** (что отрисовано позже — сверху).
- Даже если exitGroups созданы “раньше”, enterSelection может оказаться “позже” → enter сверху.
- И даже внутри exitGroups target может “закрыть” соседей, если target находится выше них в DOM-порядке (или если соседи двигаются, но попадают под большую заливку target).

---

## 3) Реалистичные гипотезы “почему сейчас не видно вытеснения” (приоритет по вероятности)

### H1 (самая вероятная): проблема layering / stacking order
**Соседи действительно двигаются, но их перекрывает expanding target или новые enter-ноды.**

Как подтверждается:
- если добавить временно opacity у target (например 0.2–0.4) и вдруг видно, что соседи летят — значит 100% layering.

### H2: enter-ноды рисуются сразу и маскируют exit
Сейчас при drilldown enter-ноды ставятся в финальные координаты, без fade, и появляются сразу (в той же итерации эффекта).  
Даже если exit летит — визуально может “не читаться”.

### H3: exitingNodesRef фильтруется как “siblings” и получается мало/0
В контейнере сейчас siblings считаются по `(depth + parentName)`.  
Если `parentName` не установлен/неконсистентен для некоторых глубин, можно получить “соседи” = 1 (только target) → тогда реально двигаться будет только target (и это полностью совпадает с вашим симптомом).

### H4: clickedNodeName не уникален
Если повторяются имена команд/юнитов/стейкхолдеров, `.find(n => n.name === clickedNodeName)` может выбрать “не того” узла. Тогда zoomTarget не соответствует реально кликнутому, и push становится странным/незаметным.

---

## 4) Вероятность успеха при дальнейших итерациях

Я бы оценил так (именно для “эффекта как у Flourish”):

- **Если цель — “видно, что соседи улетают” (без 100% идентичности Flourish): 70–85%**
  - Это достижимо через управление слоями + задержки/opacity.
- **Если цель — “максимально как Flourish” (реальный camera zoom на одном DOM без пересборки): 30–50%**
  - Потому что это требует архитектурного разворота: зумить transform контейнера, а не пересоздавать дерево на drilldown.

То есть “решение есть”, но “как Flourish один-в-один” в нашей текущей архитектуре — сильно дороже.

---

## 5) Какие шаги диагностики вы можете предпринять, чтобы я точно увидел, почему сейчас не работает

### Важно: вы сейчас на route `/auth`
Чтобы проверять treemap-анимации, нужно быть на главной странице с treemap (обычно `/`), иначе вы просто не триггерите нужный код.

### Что нужно собрать (минимальный набор)
1) Откройте страницу с treemap.
2) Откройте DevTools → Console.
3) Очистите консоль.
4) Кликните на Unit (и отдельно на Team, и отдельно в Stakeholders).
5) Скопируйте в файл/сообщение фрагменты логов, где есть:
   - `[LAYOUT] Saved flattened nodes: ...`
   - `[DRILLDOWN] clickedNodeName changed: ...`
   - `[DRILLDOWN] Found clicked node: ... depth: ...`
   - `[DRILLDOWN] exitingNodes (siblings): ...`
   - `[D3] Drilldown with exitingNodes: ... zoomTarget: ...`
6) Дополнительно (супер полезно): сделайте скриншот DOM-структуры SVG в момент анимации:
   - Elements → найдите `<svg>` treemap
   - покажите порядок дочерних `<g>`: где `g.exiting-node` относительно `g.treemap-node`

### Прямо по логам можно диагностировать:
- Если **нет** `[D3] Drilldown with exitingNodes...` → ветка drilldown-слоя не запустилась (проблема в animationType/zoomTarget/exitingNodes.length).
- Если `[D3] ... exitingNodes: 4`, но визуально нет улёта → почти точно layering/перекрытие.
- Если `exitingNodes (siblings): 1` → реальная причина “двигается только target”: соседи вообще не передаются.

---

## 6) Стоит ли продолжать менять анимации или принять текущую реализацию

### Продолжать имеет смысл, если:
- вам принципиально нужен именно “camera push” эффект как важная часть UX,
- вы готовы на ещё 1–2 итерации именно по D3Layer (слои/тайминги/идентификаторы).

### Принять текущую реализацию стоит, если:
- анимация — не критична, а важнее стабильность,
- вы хотите избежать дальнейшего усложнения D3/React синхронизации.

Моя рекомендация: **сделать ещё 1 итерацию, но строго сфокусированную на диагностике “слои и порядок отрисовки”**. Если после неё всё ещё “только target” — тогда либо:
- переходим к упрощённому варианту (fade/scale), либо
- делаем архитектурный разворот под Flourish-стиль (zoom transform, без пересоздания дерева на drilldown).

---

# Что именно делать дальше (следующая итерация, технический план)

## Цель итерации
Сделать так, чтобы “соседи” были визуально видимы во время drilldown и реально улетали.

## Изменения (TreemapD3Layer.tsx)
1) **Ввести явные слои внутри SVG**:
   - `g.enter-layer`
   - `g.exit-layer`
   - внутри `exit-layer`: отдельно `g.exit-target` и `g.exit-neighbors` (или сортировка данных так, чтобы соседи рисовались поверх target)
2) **Порядок отрисовки**:
   - enter-layer должен быть **под** exit-layer на время drilldown
   - exit-neighbors должен быть **над** exit-target (чтобы расширяющийся target не закрывал соседей)
3) **Сделать новые enter-ноды на drilldown временно невидимыми** (например opacity 0 первые 150–250мс), чтобы они не маскировали exit.
4) **Диагностический toggle** (временный):
   - на время drilldown ставить target opacity 0.35–0.5 на первые 70–80% duration, чтобы подтвердить layering-гипотезу (потом вернуть 1).

## Изменения (TreemapContainer.tsx)
1) Перейти от `clickedNodeName` к более надёжной идентификации:
   - вариант A: `clickedNodePath` (лучше всего, уже есть `path` в `TreemapLayoutNode`)
   - вариант B: `clickedNodeKey`
2) В exitingNodesRef хранить именно тот набор “соседей”, который соответствует видимому уровню:
   - при клике Unit: depth 0, parentName undefined
   - при клике Team: depth 1, parentName = UnitName
   - Stakeholders: аналогично, но важно что там всегда showTeams/showInitiatives=true
3) Добавить строгие логи:
   - сколько siblings, какие keys/paths, кто target

## Критерии “готово”
- В логах: `[D3] Drilldown with exitingNodes: N` где N ≥ 2 при клике на Unit (обычно 3–6).
- В UI: при drilldown видно, что хотя бы часть соседей реально смещается к краям (не исчезает мгновенно).

## Оценка трудозатрат
- 1 итерация на слои/тайминги: средняя сложность.
- Если подтвердим layering и починим — дальнейшие итерации минимальны (cleanup/debug).

