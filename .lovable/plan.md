
# Анализ предложения по fade текста: что мы упустили

## 1. Проблемы в текущем предложении

### 1.1. Смена размера шрифта — дерганье без перемещения

Сейчас `TreemapNodeContent` выбирает размер шрифта (9px / 11px / 14px) на основе `node.width` и `node.height`. При zoom-in блок увеличивается, и шрифт может прыгнуть с 9px на 14px **мгновенно**. Это визуально неприятно, и наше предложение с fade это **не покрывает** — displacement может быть маленьким (блок остается на месте, просто растет), но шрифт все равно скачет.

**Решение**: добавить в условие `needsTextFade` проверку на смену размерной категории (tiny/small/normal). Если категория меняется — тоже делать fade.

### 1.2. Текст, который появляется/исчезает по условию `node.height < 30`

`TreemapNodeContent` возвращает `null` при `height < 30`. Когда блок вырастает с 25px до 60px, текст появится мгновенно без fade. Аналогично, бюджет (`showValue`) появляется/исчезает при `height > 40`. Наше предложение не покрывает этот случай, потому что `motion.div` оборачивает контент, но если контент = null, анимировать нечего.

**Решение**: вместо `return null`, возвращать контейнер с `opacity: 0`, чтобы Framer Motion мог анимировать появление.

### 1.3. Текст родительского узла при zoom-in

При drill-down в юнит, его заголовок (текст сверху, как label группы) остается видимым, но блок масштабируется до заполнения viewport. Текст "Юнит А" остается в том же месте, но контейнер уезжает за пределы видимой области. Это нужно обрабатывать отдельно.

### 1.4. `memo` + `useRef` конфликт

`TreemapNode` обернут в `memo`. Если `node` пересоздается (новый объект с теми же координатами), `memo` пропустит рендер, и `prevPosRef` не обновится. Но если `node` — новый объект (что вероятно, т.к. `useMemo` в `useTreemapLayout` создает новые объекты), `memo` **не пропустит** рендер, и все будет работать. Однако стоит убедиться, что `memo` сравнивает корректно.

## 2. Как это делают лучшие

### 2.1. Flourish Treemap
- Текст **всегда** fade-out перед переходом и fade-in после
- Исключение: очень мелкие перемещения (фильтр по значению, не меняющий layout сильно)
- Fade-out текста быстрый (~150ms), fade-in медленнее (~300ms) — асимметрия создает ощущение "чистоты"

### 2.2. D3 Animated Treemap (Observable)
- Использует `treemapResquarify` — специальный tiling алгоритм, который **сохраняет относительные позиции** узлов при обновлении данных. Это минимизирует перемещения в принципе
- Текст просто перемещается вместе с блоком (допустимо, потому что перемещения малы)

### 2.3. Apple Stocks App / Финансовые Treemaps
- Текст скрыт во время любого transition
- После transition — плавное появление
- Используют crossfade: старый текст fade-out, новый fade-in одновременно

## 3. Дополнительные улучшения

### 3.1. Асимметричный timing для fade

Вместо симметричного `[0, 0.15, 0.7, 1]`, лучше:
- Fade-out: быстрый (первые 10-15% анимации)
- Fade-in: начинается на 75-80%, заканчивается на 100%

Это создает "чистое окно" в середине, когда блоки двигаются без текста.

### 3.2. `treemapResquarify` вместо `treemapSquarify`

D3 имеет специальный алгоритм `treemapResquarify`, который при обновлении данных сохраняет **топологию** (взаимное расположение узлов). Это радикально уменьшает displacement при фильтрации. Сейчас используется дефолтный `treemapSquarify`, и при изменении фильтров блоки могут полностью перетасоваться.

**Но**: `resquarify` работает только для обновления значений, не для добавления/удаления узлов. Для drill-down он не поможет.

### 3.3. Clipping текста за пределами родителя

Сейчас `overflow: hidden` на узлах. Но при zoom-out, когда блок сжимается, текст может на мгновение "вылезти" визуально (из-за timing разницы между геометрией и текстом). Стоит убедиться, что `overflow: hidden` срабатывает корректно во всех случаях.

## 4. Итоговое предложение

Реализовать в два этапа:

**Этап 1** (основной — fade текста):
- Добавить `useRef` для предыдущей позиции в `TreemapNode`
- Условие fade: displacement > 50px ИЛИ sizeChange > 30% ИЛИ смена размерной категории шрифта
- Асимметричный timing: быстрый fade-out (10%), чистая зона (65%), плавный fade-in (25%)
- Обработка появления текста из `null` (height < 30 -> height > 30): всегда с fade-in

**Этап 2** (опционально — стабильность layout):
- Попробовать `treemapResquarify` для случаев обновления данных (фильтры по кварталам)
- Оценить визуальный эффект — если позиции стабильнее, можно поднять порог displacement

### Технические детали этапа 1

**Файл**: `src/components/treemap/TreemapNode.tsx`

1. Добавить `useRef` и `useEffect` (~10 строк)
2. Вычисление `needsTextFade` с тремя условиями (~8 строк)
3. Обертка `TreemapNodeContent` в `motion.div` с keyframes (~15 строк)
4. Изменить `TreemapNodeContent`: вместо `return null` при `height < 30` — возвращать пустой div с `opacity: 0` (~3 строки)

Итого: ~35 строк изменений в 1 файле.
